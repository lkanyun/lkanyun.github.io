<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>抬头看云的博客</title>
  
  
  <link href="https://blog.lkanyun.com/atom.xml" rel="self"/>
  
  <link href="https://blog.lkanyun.com/"/>
  <updated>2024-08-30T11:53:00.937Z</updated>
  <id>https://blog.lkanyun.com/</id>
  
  <author>
    <name>抬头看云</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Linux开机自启示例</title>
    <link href="https://blog.lkanyun.com/2023/11/30/Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%A4%BA%E4%BE%8B/"/>
    <id>https://blog.lkanyun.com/2023/11/30/Linux%E5%BC%80%E6%9C%BA%E8%87%AA%E5%90%AF%E7%A4%BA%E4%BE%8B/</id>
    <published>2023-11-30T11:30:55.000Z</published>
    <updated>2024-08-30T11:53:00.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p><code>systemd</code>是Linux系统中一个系统和服务管理器，用于启动和管理系统上运行的服务。利用<code>systemctl</code>创建开机自启服务，实际上是把你的服务交给<code>systemd</code>来管理。</p><h1 id="创建步骤"><a href="#创建步骤" class="headerlink" title="创建步骤"></a>创建步骤</h1><h2 id="创建service文件"><a href="#创建service文件" class="headerlink" title="创建service文件"></a>创建service文件</h2><p>系统的服务在<code>/etc/systemd/system/</code>目录下，自定义的服务在<code>/usr/lib/systemd/system/</code>目录下，建一个<code>.service</code>结的尾文件，在这个文件里编写配置。</p><p>创建一个frps服务：<code>/usr/lib/systemd/system/frps.service</code></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[Unit]</span></span><br><span class="line"><span class="attr">Description</span>=frps</span><br><span class="line"><span class="attr">After</span>=network.target</span><br><span class="line"></span><br><span class="line"><span class="section">[Service]</span></span><br><span class="line"><span class="attr">Type</span>=simple</span><br><span class="line"><span class="attr">ExecStart</span>=/usr/local/frps/frps -c /usr/local/frps/frps.ini</span><br><span class="line"><span class="attr">ExecReload</span>=/bin/kill -s HUP <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">ExecStop</span>=/bin/kill -s QUIT <span class="variable">$MAINPID</span></span><br><span class="line"><span class="attr">PrivateTmp</span>=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[Install]</span></span><br><span class="line"><span class="attr">WantedBy</span>=multi-user.target</span><br></pre></td></tr></table></figure><p>参数解释</p><ul><li>[Unit] 部分定义了服务的描述和依赖关系<ul><li>After 定义了在哪个服务以后启动</li></ul></li><li>[Service] 部分定义了服务的执行方式和其他属性<ul><li>Type 服务类型，默认simple表示一个的简单后台进程，forking表示启动时fork一个子进程</li><li>ExecStart 启动命令</li><li>ExecReload 重启命令</li><li>ExecStop 关闭命令</li><li>WorkingDirectory 指定服务的工作目录</li><li>PrivateTmp 是否使用私有文件系统，true表示会在临时文件系统中运行，不会访问系统其他临时文件</li></ul></li><li>[Install] 部分定义了服务的安装目标<ul><li>WantedBy 哪个在目录下启动服务，multi-user.target表示多用户环境下启用服务<h2 id="服务命令"><a href="#服务命令" class="headerlink" title="服务命令"></a>服务命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">重新加载系统配置，执行以后我们新创建的配置就可以被systemd管理了</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看服务状态</span></span><br><span class="line">systemctl status frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动服务</span></span><br><span class="line">systemctl status frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭服务</span></span><br><span class="line">systemctl stop frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">加入开机自启</span></span><br><span class="line">systemctl enable frps</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">关闭开机自启</span></span><br><span class="line">systemctl disable frps</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h1&gt;&lt;p&gt;&lt;code&gt;systemd&lt;/code&gt;是Linux系统中一个系统和服务管理器，用于启动和管理系统上运行的服务。利用&lt;code&gt;system</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lkanyun.com/categories/linux/"/>
    
    
    <category term="运维" scheme="https://blog.lkanyun.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="示例" scheme="https://blog.lkanyun.com/tags/%E7%A4%BA%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>Windows10使用笔记</title>
    <link href="https://blog.lkanyun.com/2023/06/27/Windows10%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    <id>https://blog.lkanyun.com/2023/06/27/Windows10%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/</id>
    <published>2023-06-26T16:45:32.000Z</published>
    <updated>2024-08-30T11:53:00.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1、软链接"><a href="#1、软链接" class="headerlink" title="1、软链接"></a>1、软链接</h1><p> <strong>1.1、创建软链接：</strong> 将D盘的文件或文件夹链接至C盘，可以直接使用C盘的链接文件，实际操作的文件存在D盘，可以降低C盘空间，又不影响某些软件的使用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">mklink /d 链接路径  目标路径</span></span><br><span class="line">mklink /d C:\test\linkDirA D:\linkDir\linkDirA</span><br></pre></td></tr></table></figure><p> <strong>1.2、删除软链接：</strong> 在windows资源管理器中可以直接删除带有链接符号的文件或文件夹，不影响原始文件，命令行使用rmdir删除链接文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir C:\test\linkDirA</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>如果使用del命令，会将原始文件删除。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1、软链接&quot;&gt;&lt;a href=&quot;#1、软链接&quot; class=&quot;headerlink&quot; title=&quot;1、软链接&quot;&gt;&lt;/a&gt;1、软链接&lt;/h1&gt;&lt;p&gt; &lt;strong&gt;1.1、创建软链接：&lt;/strong&gt; 将D盘的文件或文件夹链接至C盘，可以直接使用C盘的链接文件</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>GoReplay-流量录制与回放</title>
    <link href="https://blog.lkanyun.com/2020/12/17/GoReplay-%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E4%B8%8E%E5%9B%9E%E6%94%BE/"/>
    <id>https://blog.lkanyun.com/2020/12/17/GoReplay-%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6%E4%B8%8E%E5%9B%9E%E6%94%BE/</id>
    <published>2020-12-17T08:56:36.000Z</published>
    <updated>2024-08-30T11:53:00.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="GoReplay简介"><a href="#GoReplay简介" class="headerlink" title="GoReplay简介"></a>GoReplay简介</h3><p>GoReplay是一个开源的网络监控工具，它可以记录你的实时流量，并用于跟踪、负载测试、监控和详细分析。录制的流量可以在测试服务器上回放，并支持请求放大，用于性能测试。<br><strong>github主页:</strong> <a href="https://github.com/buger/goreplay">https://github.com/buger/goreplay</a>  </p><h3 id="GoReplay安装—linux"><a href="#GoReplay安装—linux" class="headerlink" title="GoReplay安装—linux"></a>GoReplay安装—linux</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下载安装包</span></span><br><span class="line">wget https://github.com/buger/goreplay/releases/download/v1.1.0/gor_1.1.0_x64.tar.gz</span><br><span class="line"><span class="comment"># 解压 得到二进制文件gor</span></span><br><span class="line">tar -zxvf gor_1.1.0_x64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="GoReplay安装—windows"><a href="#GoReplay安装—windows" class="headerlink" title="GoReplay安装—windows"></a>GoReplay安装—windows</h3><p><strong>文档地址：</strong> <a href="https://github.com/buger/goreplay/wiki/Running-on-Windows">https://github.com/buger/goreplay/wiki/Running-on-Windows</a>  </p><p>安装nmap工具，进行流量的抓取,地址<a href="https://nmap.org/npcap/">nmap</a>或者<a href="https://technet.microsoft.com/en-us/library/cc708322.aspx">technet</a>，直接下载<a href="https://nmap.org/dist/nmap-7.80-setup.exe">nmap</a>,安装时勾选带有WinPcap的选项<br>win版二进制文件<a href="https://github.com/buger/goreplay/files/1696582/goreplay.zip">goreplay.zip</a>  </p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、如果没有web服务，可以在本地启动一个8000端口的文件服务器，并实时打印流量在控制台</span></span><br><span class="line">./gor file-server :8000</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2、获取8000端口的包，并打印在控制台</span></span><br><span class="line"><span class="built_in">sudo</span> ./gor --input-raw :8000 --output-stdout</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取8000端口的包，并保存在.gor文件中</span></span><br><span class="line"><span class="built_in">sudo</span> ./gor --input-raw :8080 --output-file=request.gor</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转发：录制8000端口的包，并推送的测试系统</span></span><br><span class="line"><span class="built_in">sudo</span> ./gor --input-raw :8000 --output-http http://staging.env</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转发至多个地址,默认每一条记录都发送到所有地址</span></span><br><span class="line"><span class="built_in">sudo</span> gor --input-tcp :28020 --output-http <span class="string">&quot;http://staging.com&quot;</span>  --output-http <span class="string">&quot;http://dev.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 转发至多个地址，轮询发送</span></span><br><span class="line"><span class="built_in">sudo</span> gor --input-raw :80 --output-http <span class="string">&quot;http://staging.com&quot;</span>  --output-http <span class="string">&quot;http://dev.com&quot;</span> --split-output <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 参数input-raw表示只记录请求信息，而参数--input-raw-track-response可以记录请求和响应</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认使用libpcap拦截流量，如果有问题，可以使用替代引擎raw_socket</span></span><br><span class="line"><span class="built_in">sudo</span> gor --input-raw :80 --input-raw-engine <span class="string">&quot;raw_socket&quot;</span> --output-http <span class="string">&quot;http://staging.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用--input-raw-realip-header可以记录IP，header名称通常是X-Real_IP</span></span><br><span class="line"><span class="built_in">sudo</span> gor --input-raw :80 --input-raw-realip-header <span class="string">&quot;X-Real-IP&quot;</span> ...</span><br></pre></td></tr></table></figure><h3 id="从文件保存和回放"><a href="#从文件保存和回放" class="headerlink" title="从文件保存和回放"></a>从文件保存和回放</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 写入文件</span></span><br><span class="line">gor --input-raw :80 --output-file requests.log</span><br><span class="line"></span><br><span class="line"><span class="comment"># 从文件读取</span></span><br><span class="line">gor --input-file requests.gor --output-http <span class="string">&quot;http://staging.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 分文件存储，以时间格式保存，默认以块的形式追加，将不同的块到不同的文件</span></span><br><span class="line">gor ... --output-file %Y%m%d.log</span><br><span class="line"><span class="comment"># append false</span></span><br><span class="line">20140608_0.<span class="built_in">log</span></span><br><span class="line">20140608_1.<span class="built_in">log</span></span><br><span class="line">20140609_0.<span class="built_in">log</span></span><br><span class="line">20140609_1.<span class="built_in">log</span></span><br><span class="line"><span class="comment"># 使用--output-file-append使文件不分块，都追加到同一个文件</span></span><br><span class="line">gor ... --output-file %Y%m%d.log --output-file-append</span><br><span class="line"><span class="comment"># append true</span></span><br><span class="line">20140608.<span class="built_in">log</span></span><br><span class="line">20140609.<span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 块大小--output-file-size-limit限制块大小--output-file-queue-limit限制队列，如果只限制大小：</span></span><br><span class="line">gor --input-raw :80 --output-file %Y-%m-%d.gz --output-file-size-limit 256m --output-file-queue-limit 0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 文件名可以使用改的时间参数</span></span><br><span class="line">%Y:年 %m:月 %d:日 %H:时 %M:分 %S:秒</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读写SGZIP压缩文件，以.gz结尾</span></span><br><span class="line">...--output-file log.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用正则表达式读取多个文件，如：log2020*，根据时间戳给所有的文件请求进行排序</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 以多倍的速度进行回放，可以减缓或加快起速度，例：两倍速回放</span></span><br><span class="line">gor --input-file <span class="string">&quot;requests.gor|200%&quot;</span> --output-http <span class="string">&quot;staging.com&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环回放，当请求较少时，可以使用--input-file-loop循环回放，当回放完所有文件时，不会停止，而是从第一个重新开始</span></span><br></pre></td></tr></table></figure><h3 id="记录response"><a href="#记录response" class="headerlink" title="记录response"></a>记录response</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 加入参数--input-raw-track-response即可</span></span><br><span class="line">./gor --input-raw :8081 --input-raw-track-response --output-file uat-request%Y%m%d%H.<span class="built_in">log</span> --output-file-append --http-disallow-url .*order.* .*aliPay.* .*wxPay.* .*refund.*</span><br></pre></td></tr></table></figure><h3 id="远程转发"><a href="#远程转发" class="headerlink" title="远程转发"></a>远程转发</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转发至127.0.0.1：2020</span></span><br><span class="line">./gor --input-raw :8081 --output-tcp 127.0.0.1:2020 --http-allow-url /admin</span><br><span class="line"><span class="comment"># 从远程接收</span></span><br><span class="line">./gor --input-tcp :2020 --output-file admin-%Y%m%d%H.<span class="built_in">log</span> --output-file-append</span><br></pre></td></tr></table></figure><h3 id="速度限制"><a href="#速度限制" class="headerlink" title="速度限制"></a>速度限制</h3><p>输入和输出都支持速度限制，在上一个已经介绍了读取文件速度限制。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 每秒钟不超过10条</span></span><br><span class="line">gor --input-tcp :28020 --output-http <span class="string">&quot;http://staging.com|10&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 回放速度减缓10%</span></span><br><span class="line">gor --input-raw :80 --output-tcp <span class="string">&quot;replay.local:28020|10%&quot;</span></span><br></pre></td></tr></table></figure><p>可以根据请求头或地址参数设置回放速度限制，只按照这部分进行限速，只支持百分比</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 根据请求头限制速度</span></span><br><span class="line">gor --input-raw :80 --output-tcp <span class="string">&quot;replay.local:28020|10%&quot;</span> --http-header-limiter <span class="string">&quot;X-API-KEY: 10%&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据URL参数限制速度</span></span><br><span class="line">gor --input-raw :80 --output-tcp <span class="string">&quot;replay.local:28020|10%&quot;</span> --http-param-limiter <span class="string">&quot;api_key: 10%&quot;</span></span><br></pre></td></tr></table></figure><h3 id="请求过滤"><a href="#请求过滤" class="headerlink" title="请求过滤"></a>请求过滤</h3><p>如果只想抓取特定的请求，可以进行过滤，支持URL地址，HTTP header或者HTTP method</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 正则匹配url，转发URL中包含/api的请求</span></span><br><span class="line">gor --input-raw :8080 --output-http staging.com --http-allow-url /api</span><br><span class="line"><span class="comment"># 只转发不包含order、aliPay、wxPay、refund，正则表达式</span></span><br><span class="line">./gor --input-raw :8081 --output-file uat-request%Y%m%d%H.<span class="built_in">log</span> --output-file-append --http-disallow-url .*order.* .*aliPay.* .*wxPay.* .*refund.*</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只转发不包含 /api 的请求</span></span><br><span class="line">gor --input-raw :8080 --output-http staging.com --http-disallow-url /api</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只转发 api 版本为 1.0x 的</span></span><br><span class="line">gor --input-raw :8080 --output-http staging.com --http-allow-header api-version:^1\.0\d</span><br><span class="line"></span><br><span class="line"><span class="comment"># 只转发请求头 User-Agent 的值是 &quot;Replayed by Gor&quot;的</span></span><br><span class="line">gor --input-raw :8080 --output-http staging.com --http-disallow-header <span class="string">&quot;User-Agent: Replayed by Gor&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 根据请求方法（GET、POSt……）进行过滤</span></span><br><span class="line">gor --input-raw :80 --output-http <span class="string">&quot;http://staging.server&quot;</span> \</span><br><span class="line">    --http-allow-method GET \</span><br><span class="line">    --http-allow-method OPTIONS</span><br></pre></td></tr></table></figure><h3 id="请求重写"><a href="#请求重写" class="headerlink" title="请求重写"></a>请求重写</h3><p>gor支持对URL、URL参数和header的重写。可以用于将token进行重写，完成测试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重写所有的`/v1/user/&lt;user_id&gt;/ping`为`/v2/user/&lt;user_id&gt;/ping`，可以使用正则表达式，用“:”进行分割</span></span><br><span class="line">gor --input-raw :8080 --output-http staging.com --http-rewrite-url /v1/user/([^\\/]+)/ping:/v2/user/<span class="variable">$1</span>/ping</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置URL的参数，如果参数已经存在则覆盖</span></span><br><span class="line">gor --input-raw :8080 --output-http staging.com --http-set-param api_key=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置自定义header，如果header已经存在则覆盖</span></span><br><span class="line">gor --input-raw :80 --output-http <span class="string">&quot;http://staging.server&quot;</span> \</span><br><span class="line">    --http-header <span class="string">&quot;User-Agent: Replayed by Gor&quot;</span> \</span><br><span class="line">    --http-header <span class="string">&quot;Enable-Feature-X: true&quot;</span></span><br></pre></td></tr></table></figure><h3 id="分布式配置"><a href="#分布式配置" class="headerlink" title="分布式配置"></a>分布式配置</h3><p>一个服务有台服务器组成集群，gor对每天服务器进行请求转发，将集群的请求集中一起。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在每一个服务将流量转发至replay.local:28020</span></span><br><span class="line"><span class="built_in">sudo</span> gor --input-raw :80 --output-tcp replay.local:28020</span><br><span class="line"></span><br><span class="line"><span class="comment"># 回放服务</span></span><br><span class="line">gor --input-tcp replay.local:28020 --output-http http://staging.com</span><br></pre></td></tr></table></figure><p>如果要转发至多个服务中，可以使用–split-output，它可以轮询将入口流量回放到多个服务中</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将流量轮询回放到两个服务</span></span><br><span class="line">gor --input-raw :80 --split-output --output-tcp replay1.local:28020 --output-tcp replay2.local:28020</span><br></pre></td></tr></table></figure><p>它还可以更智能的将同一个会话传递到同一个服务中，控制流量的从属。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取多个文件、10倍速回放、30s循环、根据session分布式流量发送给多个服务</span></span><br><span class="line">gor --input-file logs_from_multiple_machines.*|1000% --input-file-loop --exit-after 30s --recognize-tcp-sessions --split-output --output-tcp worker1.local --output-tcp worker2.local:27017 --output-tcp worker3.local:27017 ...  --output-tcp workerN.<span class="built_in">local</span>:27017</span><br><span class="line"></span><br><span class="line"><span class="comment"># worker </span></span><br><span class="line">gor --input-tcp :27017 --ouput-http load_test.target</span><br></pre></td></tr></table></figure><h3 id="和Kafka配合使用"><a href="#和Kafka配合使用" class="headerlink" title="和Kafka配合使用"></a>和Kafka配合使用</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 记录数据</span></span><br><span class="line">gor --input-raw :8080 --output-kafka-host <span class="string">&#x27;192.168.0.1:9092,192.168.0.2:9092&#x27;</span> --output-kafka-topic <span class="string">&#x27;kafka-log&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取数据</span></span><br><span class="line">gor --input-kafka-host <span class="string">&#x27;192.168.0.1:9092,192.168.0.2:9092&#x27;</span> --input-kafka-topic <span class="string">&#x27;kafka-log&#x27;</span> --output-stdout</span><br></pre></td></tr></table></figure><p>通过–output-kafka-json-format和–input-kafka-json-format可以使用json格式进行读取和推送，但是会影响性能</p><h3 id="参数解释"><a href="#参数解释" class="headerlink" title="参数解释"></a>参数解释</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">--input-raw -用户捕获HTTP流量，应指定IP（接口）以及端口</span><br><span class="line">--input-file - 读取记录的文件，通过其他方式回放</span><br><span class="line">--input-tcp - 将流量从多个转发gor转发到该实例</span><br><span class="line">--output-http - 回放HTTP请求到指定站点，接受基本url</span><br><span class="line">--output-file - 将HTTP请求流量到文件</span><br><span class="line">--output-tcp - 将流量转发到另一个gor实例，使用--input-tcp接受</span><br><span class="line">--output-stdout - 将THHP请求打印到控制台，在调试时使用</span><br></pre></td></tr></table></figure><h3 id="不使用root用户运行"><a href="#不使用root用户运行" class="headerlink" title="不使用root用户运行"></a>不使用root用户运行</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1、将gor文件放到/usr/local/bin中</span></span><br><span class="line"><span class="comment"># 2、创建gor组和用户</span></span><br><span class="line">groupadd gor</span><br><span class="line">useradd -g gor gor</span><br><span class="line"><span class="comment"># 3、将gor文件所属给gor用户，设置权限</span></span><br><span class="line"><span class="built_in">chgrp</span> gor /usr/local/gor</span><br><span class="line"><span class="built_in">chmod</span> 0750 /usr/lcoa/gor</span><br><span class="line"><span class="comment"># 4、分割root用户特权</span></span><br><span class="line"><span class="built_in">setcap</span> <span class="string">&quot;cap_net_raw,cap_net_admin+eip&quot;</span> /usr/local/bin/gor</span><br></pre></td></tr></table></figure><p>至此，可以直接使用gor命令运行</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;GoReplay简介&quot;&gt;&lt;a href=&quot;#GoReplay简介&quot; class=&quot;headerlink&quot; title=&quot;GoReplay简介&quot;&gt;&lt;/a&gt;GoReplay简介&lt;/h3&gt;&lt;p&gt;GoReplay是一个开源的网络监控工具，它可以记录你的实时流量，并用于跟踪</summary>
      
    
    
    
    <category term="网络工具" scheme="https://blog.lkanyun.com/categories/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    
    <category term="java" scheme="https://blog.lkanyun.com/tags/java/"/>
    
    <category term="流量录制" scheme="https://blog.lkanyun.com/tags/%E6%B5%81%E9%87%8F%E5%BD%95%E5%88%B6/"/>
    
    <category term="网络工具" scheme="https://blog.lkanyun.com/tags/%E7%BD%91%E7%BB%9C%E5%B7%A5%E5%85%B7/"/>
    
    <category term="性能测试" scheme="https://blog.lkanyun.com/tags/%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Centos7 LVM空间转移</title>
    <link href="https://blog.lkanyun.com/2020/12/14/Centos7-LVM%E7%A9%BA%E9%97%B4%E8%BD%AC%E7%A7%BB/"/>
    <id>https://blog.lkanyun.com/2020/12/14/Centos7-LVM%E7%A9%BA%E9%97%B4%E8%BD%AC%E7%A7%BB/</id>
    <published>2020-12-14T01:54:55.000Z</published>
    <updated>2024-08-30T11:53:00.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h3><p>安装了Centos7之后，发现root分区不够用，而大部分分区都在home。磁盘是通过LVM进行管理，可以在线将home分区缩减，并将root分区扩容。由于LVM的特性，逻辑卷扩容时不需要卸载分区，可以实现不停机扩容。</p><h3 id="二、知识"><a href="#二、知识" class="headerlink" title="二、知识"></a>二、知识</h3><h4 id="1、LVM介绍"><a href="#1、LVM介绍" class="headerlink" title="1、LVM介绍"></a>1、LVM介绍</h4><p><strong>LVM</strong> 是一种可用在Linux内核的逻辑分卷管理器；可用于管理磁盘驱动器或其他类似的大容量存储设备。<strong>LVM独立于物理磁盘</strong>，可以实现存储空间的抽象化并在上面建立虚拟分区，可以更加简易地扩大和缩小分区，可以增删分区时无需担心某个物理硬盘上没有足够的连续空间，避免为正在使用的磁盘重新分区的麻烦。</p><p>LVM的基本组成如下：</p><p><strong>物理卷 (PV)</strong></p><p>一个可供存储LVM的块设备，也就是物理硬盘。如果新加入的一块硬盘要作为正在使用的分区的扩充，就需要先把硬盘创建成物理卷。</p><p><strong>卷组 (VG)</strong></p><p>物理卷的一个组，作为存放逻辑卷的容器。 不同硬盘的物理卷可以组成同一个卷组，然后可以把卷组的空间分配给逻辑卷，这样不同硬盘也可以被分配到同一个分区，并且可以动态的扩大和缩小。</p><p><strong>逻辑卷 (LV)</strong></p><p>“虚拟/逻辑卷”存放在一个卷组中并由物理块组成。是一个类似于物理设备的块设备，例如，你可以直接在它上面创建一个文件系统文件系统。</p><p><strong>物理块 (PE)</strong></p><p>一个卷组中最小的连续区域(默认为4 MiB)，多个物理块将被分配给一个逻辑卷。你可以把它看成物理卷的一部分，这部分可以被分配给一个逻辑卷。</p><p>示例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">`物理硬盘`</span><br><span class="line">               </span><br><span class="line">   硬盘1 (/dev/sda):</span><br><span class="line">      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </span><br><span class="line">     |分区1 50GB (物理卷)           |分区2 80GB (物理卷)            |</span><br><span class="line">     |/dev/sda1                    |/dev/sda2                     |</span><br><span class="line">     |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _|_ _ _ _ _ _ _ _ _ _ _ _ _ _ __|</span><br><span class="line">                                 </span><br><span class="line">   硬盘2 (/dev/sdb):</span><br><span class="line">      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _</span><br><span class="line">     |分区1 120GB (物理卷)                         |</span><br><span class="line">     |/dev/sdb1                                   |</span><br><span class="line">     | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|</span><br><span class="line">   </span><br><span class="line">`LVM逻辑卷`</span><br><span class="line"> </span><br><span class="line">   卷组（Volume Group1） (/dev/MyVolGroup/ = /dev/sda1 + /dev/sda2 + /dev/sdb1):</span><br><span class="line">      _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ </span><br><span class="line">     |逻辑卷1 15GB                  |逻辑卷2 35GB                        |逻辑卷3 200GB                           |</span><br><span class="line">     |/dev/MyVolGroup/rootvol        |/dev/MyVolGroup/homevol             |/dev/MyVolGroup/mediavol           |</span><br><span class="line">     |_ _ _ _ _ _ _ _ _ _ _ _ _ _ __|_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ __ |_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _|</span><br></pre></td></tr></table></figure><h4 id="2、System-Storage-Manager介绍"><a href="#2、System-Storage-Manager介绍" class="headerlink" title="2、System Storage Manager介绍"></a>2、System Storage Manager介绍</h4><p><strong>System Storage Manager</strong>是一个用来管理各种文件系统的命令行工具，可以管理包括LVM、btrfs和加密卷等文件系统，可以简化存储管理。通过ssm可以自动完成lvm自动完成<strong>LVM的创建，文件系统创建和挂载</strong>。下面，我们通过ssm工具将home分区空间转移到root分区。</p><h3 id="三、实践"><a href="#三、实践" class="headerlink" title="三、实践"></a>三、实践</h3><h4 id="1、查看分区情况"><a href="#1、查看分区情况" class="headerlink" title="1、查看分区情况"></a>1、查看分区情况</h4><p>在root空间不够用时，笔者尝试过其他教程，将home空间缩小，其中的一部分给root，但是失败了，从资料3得知可能home的文件系统不支持缩减，故直接删除。</p><p>执行<strong>lsblk</strong>命令，查看磁盘分区，磁盘sda2被分成了三个逻辑卷，类型都是LVM，大部分磁盘空间都分给了home。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@master ~]# lsblk</span><br><span class="line">NAME            MAJ:MIN RM    SIZE RO TYPE MOUNTPOINT</span><br><span class="line">sda               8:0    0    300G  0 disk </span><br><span class="line">├─sda1            8:1    0      1G  0 part /boot</span><br><span class="line">└─sda2            8:2    0    299G  0 part </span><br><span class="line">  ├─centos-root 253:0    0     50G  0 lvm  /</span><br><span class="line">  └─centos-swap 253:1    0   11.8G  0 lvm  [SWAP]</span><br><span class="line">  └─centos-home 253:1    0 237.18G  0 lvm  /home</span><br><span class="line">sr0              11:0    1   1024M  0 rom</span><br></pre></td></tr></table></figure><p>如果/home下有数据，请按需备份，新装系统或无文件，可以直接删除。</p><h4 id="2、通过System-Storage-Manager删除home分区，把空间增加到root里。"><a href="#2、通过System-Storage-Manager删除home分区，把空间增加到root里。" class="headerlink" title="2、通过System Storage Manager删除home分区，把空间增加到root里。"></a>2、通过System Storage Manager删除home分区，把空间增加到root里。</h4><p><strong>⭐安装System Storage Manager</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install system-storage-manager</span><br></pre></td></tr></table></figure><p><strong>⭐查看分区</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssm list</span><br></pre></td></tr></table></figure><p>发现root分区只有50G空间，home分区有237G空间。</p><p><strong>⭐卸载home</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">umount /home</span><br></pre></td></tr></table></figure><p><strong>⭐删除逻辑卷home</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssm remove /dev/centos/home</span><br></pre></td></tr></table></figure><p><strong>⭐查看释放出来的空间</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssm list</span><br></pre></td></tr></table></figure><p>home逻辑卷已经成功被删除，卷组centos有237.18G的空余，可以分配给root分区。</p><p><strong>⭐将剩余空间全部加入root分区</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssm resize -s +100%FREE /dev/centos/root</span><br></pre></td></tr></table></figure><p>root逻辑卷已经从50G增加到287.18G，由于此时操作的是LVM，文件系统并未更新分区信息，centos7还需要执行xfs_growfs同步文件系统。</p><p><strong>⭐同步文件系统</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xfs_growfs /dev/centos/root</span><br></pre></td></tr></table></figure><p><strong>⭐查看修改后的卷信息</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssm list</span><br></pre></td></tr></table></figure><p>此时，home逻辑卷已经被删除，腾出的空间都增加到root逻辑卷，目标完成。由于home分区已经被删除，还需要修改/etc/fstab文件,将挂载home的一行注释或者删除掉。</p><p><strong>⭐取消挂载home</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure><p>将红框那一行注释或者删除，wq保存退出，大功告成。</p><h3 id="三、资料"><a href="#三、资料" class="headerlink" title="三、资料"></a>三、资料</h3><p>1、archlinux-文档：<a href="https://wiki.archlinux.org/index.php/LVM_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">LVM_(简体中文)</a></p><p>2、哔哩哔哩-部分原理和操作：<a href="https://www.bilibili.com/video/av17646431">LInux LVM分区于应用详解</a></p><p>3、csdn：<a href="https://blog.csdn.net/lpwmm/article/details/103886830">CentOS7 LVM管理 把/home空间转移给/</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一、背景&quot;&gt;&lt;a href=&quot;#一、背景&quot; class=&quot;headerlink&quot; title=&quot;一、背景&quot;&gt;&lt;/a&gt;一、背景&lt;/h3&gt;&lt;p&gt;安装了Centos7之后，发现root分区不够用，而大部分分区都在home。磁盘是通过LVM进行管理，可以在线将home分区</summary>
      
    
    
    
    <category term="linux" scheme="https://blog.lkanyun.com/categories/linux/"/>
    
    
    <category term="运维" scheme="https://blog.lkanyun.com/tags/%E8%BF%90%E7%BB%B4/"/>
    
    <category term="centos7" scheme="https://blog.lkanyun.com/tags/centos7/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://blog.lkanyun.com/2020/01/01/hello-world/"/>
    <id>https://blog.lkanyun.com/2020/01/01/hello-world/</id>
    <published>2019-12-31T16:00:00.000Z</published>
    <updated>2024-08-30T11:53:00.938Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
